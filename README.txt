Серверная часть обработки записей рабочего времени.

HW3
Создание:

 контроллеров:
    TimesheetController
    ProjectController

 сервисов:
    TimesheetService
    ProjectService

 репозиториев:
    TimesheetRepository
    ProjectRepository

 А также основных CRUD-методов для работы с данными



HW4
Обновлены некоторые методы контроллеров -> сервисов -> репозиториев
Изучен принцип работы ExceptionHandler для разного вида контроллеров
Добавлены DTO для удобной работы с Thymeleaf + реализованы сами страницы (в т.ч. для статусов 404 и 500)
Добавлены гиперссылки в страницы timesheets, projects и тд



HW5
По порядку:
    добавлена сущность Employee
    контроллеры:
        EmployeeController
        EmployeePageController
    сервисы:
        EmployeeService
        EmployeePageService
    репозитории:
        EmployeeRepository

Для визуализации сотрудников, по аналогии с другими сущностями, добавлено 2 страницы,
    а также обновлен список DTO и их составляющих для визуализации

Убран редирект при ошибке возврата страницы (пока что)

Обновлена логика работы каждого сервиса и контроллера
В репозитории добавлены некоторые методы для корректной работы (некоторые переписаны)

Из особенностей:

    - метод фильтрации таймшитов по дате изменен (см TimesheetController -> findAll());

    - метод фильтрации сотрудников работает с учетом текущего положения в штате:
        по умолчанию фильтрация происходит только по тем, кто в штате числится
        увольнение сотрудника НЕ убирает его из БД, а лишь ОБНОВЛЯЕТ поле stillWork на false;
        это сделано, чтобы не терять информацию об уже законченных проектах и сохраненных таймшитах;
        следовательно, чтобы найти всех, нужно указать параметр ?stillWork=false;

    - при создании сущностей вручную придерживаться последовательности: сотрудник -> проект -> таймшиты
        тк идея в том, что база сотрудников одна и они могут существовать обособленно;
        проект также может обойтись без никого (в тч сотрудника, тк ответственных ролей у нас нет)
        а вот таймшит завязан сразу на обоих, тк без них - он бессмысленен;

    - при запуске приложения происходит инициализация данных из файла InputDataInitializer.java
        граничные значения можно выбрать любые
        ну если бы да кабы делался сервис много шире, то у сотрудника можно было бы поставить еще флажок,
        что он УЖЕ задействован где-то и поставить какое-то ограничение на это кол-во (одновременных),
        чтобы распределять нагрузку хоть как-то;
        а там уже и флажки состояния у проектов и прочее

    - есть 1 @Deprecated метод в ProjectRepository,
        оставил как память


HW6
Для контроллеров реализован swagger.
Ссылка http://localhost:8080/swagger-ui/index.html
Знаю, что можно писать кастомные ссылки для доступа к документации,
    но только при условии пользования application.properties -
    для yaml файла - не нашел.
Переделана логика сохранения timesheet, но предыдущий метод оставлен, тк, по-моему, он удобнее,
        если данных у сотрудника в виде списка будет куда больше (но пометил как @Deprecated).
Обновлена логика удаления timesheet.


HW7
БД переехала в PostgreSQL в контейнер (была некоторая необходимость видеть перед собой таблицы)
docker run --name timesheets-cont -p 5432:5432 -e POSTGRES_USER=sa -ePOSTGRES_PASSWORD=sa -e POSTGRES_DB=timesheets -d postgres
docker exec -ti timesheets-cont psql -U sa -d timesheets

По поводу swagger'а
Перечитывая статью раз 6 за все время, посетила мысль, которая все-таки позволила сделать кастомную ссылку на swagger доку
    без дополнительных классов-конфигов
    В .yaml будет ссылка для swagger'а

Добавлено:

    - контроллер для получения токена на руки (юзать в постмане) + pojo для его тела
            пост запрос с телом, например,
                                {
                                    "login": "user3",
                                    "password": "user3"
                                }
                                (других можно в InputDataInitializer глянуть)
    - правило после успешной авторизации (редиректы в соответствии с ролями)
    - jwt сервис
    - jwt фильтр (проверка валидности токена, его парсинг)

Пробовал также сделать 401 после доступа к /api/** (JSON страницы).
Вариантов было несколько:
    обработать прям в конфиге через .exceptionHandling (пример в комменте фиксми)
    сделать отдельный класс JwtAuthenticationEntryPoint с обработкой внутри
    возможно как-то подправить jwtFilter

НО безрезультатно, я попадаю в петлю при редиректе на форм логин, а как эту базовую фигню выключить не нашел
    (только как применить свою)
    получается либо выводить 401 без авторизации (как надо) + пустая страница без редиректа (как не надо)
    либо проблема и там, и там

Если короче, доп задание я не победил,
    хотя это скорее всего возможно, если мб сделать кастомную форму + контроллер и возвращать на свою страницу
    (типа контроль все дела)

Если под рукой есть инфа, как это сделать - буду рад, специально не ищите

Проверка новенького-интересного по ФИКСМИ, лишнее убрал

UPD: Может быть обработку подобного рода исключений при попытке доступа к JSON странице можно сделать через отлов исключений АОП


HW8
В папке aop аннотации и аспекты (с семинара и дз)

Logging сделан для всех 3 сервисов по разным Pointcut()
Recover сделан с учетом игнорируемых классов, описание в ФИКСМИ

Чтобы более менее проверить в классе TimesheetService в методе findById() стоит аннотация Recover, в ней класс (менять его, если хочется);
дальше можно так: (помним, что бд в PostgreSQL в докере)
    - в постмане получить Bearer на {"login": "user3", "password": "user3"}
    - в GET запрос http://localhost8080/timesheets/1 добавить токен
    - получим ошибку с сообщением в консоль (которое прилетело из метода)

-->> если класс в списке исключений, то будет ответ с сообщением из аспекта (что исключение не обрабатывается)
        новое выброшенное обработается Hndler'ом (он и тут, и дальше будет брать сообщения из тех, что выбрасывает Аспект)
-->> если не в списке, то проверяется тип возвращаемый
        примитив - по условию вернет 0
        ссылка - null
        в каждом из них прописан пример выброса еще одного рантайма (описано в ФИКСМИ)
-->> если аннотации не было то получим соответсвующее сообщение об этом
